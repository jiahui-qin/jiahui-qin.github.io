---
title: redis能不能作为消息队列？
date: 2021-04-22 19:00:38
tags:
- 转载
categories:
- 指南
---

昨天晚上睡觉之前看到一篇我觉得很好的文章，文章标题是[把 Redis 当作队列来用，真的合适吗？](https://mp.weixin.qq.com/s/QQTG7RIOgSvSIueTqOHwww)

读完之后感觉好像写的很好，我在这里大致总结一下，主要有以下几个总结点

1. 消息队列用来做什么？
2. 用redis来做消息队列有什么方法？
3. 为什么用redis来做消息队列/不做消息队列？
4. 关于这一点的思考

<!--more-->
---
## 消息队列是用来做什么的？

消息队列是一个存放消息的容器，需要使用消息时可以取出消息供使用，有以下几个好处：

* 异步处理提高系统性能，削峰
* 降低系统耦合性

常用的消息队列有 kafka, activeMQ, rabbitMQ, rocketMQ

消息队列类似与先进先出的queue数据结构，在消息队列中我们可能需要考虑以下问题：

* 消息是否有可能被重复消费？
* 消息是否有可能丢失？：在生产者处丢失、在传输过程中丢失、消费者处丢失
* 多消费者的情况下如何保证每个消费者都消费到了消息？
* 消费顺序如何保证正确？
 ······

可见引入消息队列也会使得系统可用性降低、复杂性提高、一致性处理复杂····

redis是一个内存数据库，在某种程度上也可以用来做消息队列，接下来我们详细见讲一讲

## redis怎么做消息队列？

### 最简单的方法 List

List是redis中的一个数据类型，底层实现是一个列表，直接如下操作就可以当作消息队列：

    ## 生产者发布消息：
    127.0.0.1:6379> LPUSH queue msg1
    (integer) 1
    127.0.0.1:6379> LPUSH queue msg2
    (integer) 2

    消费者这一侧，使用 RPOP 拉取消息：
    127.0.0.1:6379> RPOP queue
    "msg1"
    127.0.0.1:6379> RPOP queue
    "msg2"

这么做非常好理解，一个放数据进来，一个取数据，但是会带来什么问题呢？

没有一个消息提醒机制来告诉我们有消息进来了，所以我们需要在消费者处写一个死循环，不断的从队列中拉取数据：

    while true:
        msg = redis.rpop("queue")
        // 没有消息，继续循环
        if msg == null:
            continue
        // 处理消息
        handle(msg)

如果没有数据，那么就会造成CPU空转，如果不想要CPU空转，那就要写一个休眠时间，每隔固定时间去请求数据。这样又会引入新的问题：休眠时来消息，会造成处理消息延迟。也就是说，消息延迟和CPU空转二者是一个鱼与熊掌不可兼得的问题。

### 更高端的方式 BRPOP/BLPOP

如果队列为空，消费者就处于阻塞状态等待，有新消息过来，就通知消费者进行处理。

    while true:
        // 没消息阻塞等待，0表示不设置超时时间
        msg = redis.brpop("queue", 0)
        if msg == null:
            continue
        // 处理消息
        handle(msg)

这样就避免了上边的问题，但是缺点呢：不支持重复消费->不支持多个消费者消费同一批数据， 消息可能会丢失（无法重新消费）

### 发布/订阅模型 pub/sub

这个模型有点像BRPOP/BLPOP的进阶版本，这种模型可以解决一个问题：重复订阅

它支持阻塞式拉取消息，可以让多组消费者消费同一个生产者生产的数据

也提供了匹配订阅模式，可以使一个消费者订阅来自多个生产者的数据。

缺点在于：可能会丢数据：消费者下线、redis宕机、消息堆积···

造成整个缺点的原因在于
* pub/sub整个过程中消息是实时转发的，没有消息存储。使得消费者必须先订阅队列，生产者才可以发布消息。
* 读数据的buffer有大小限制，如果读取速度不匹配，buffer超过配置的大小，redis就会强制把消费者踢下线

### 趋于成熟的队列 Stream

redis5.0中，作者定义了一个新的数据类型Stream

Stream比较基础的指令有：

* XADD 发布消息
* XREAD 读取消息，如果要读上一条消息，要传入上一条消息的id， 读取消息的时候也可以加入BLOCK参数来支持阻塞式拉取消息
* XGROUP/XREADGROUP 创建消费者组/指定消费者组下开启消费者拉去消息（可以让多个消费者消费同一批消息）
* XACK 消费者处理完消息之后，使用XACK命令告诉redis这条数据被消费了，redis会标记这条数据处理完成（来解决丢数据的问题）

Stream是一个数据类型，会写到RDB和AOD中做数据持久化，就可以保证不在redis中丢数据

消息堆积时怎么处理？ redis会丢弃掉就消息，保留固定长度的新消息

## redis作为消息队列还有什么问题？

消息队列的两个重要问题： 1 不丢失消息  2 消息可以堆积

由于redis本身持久化的机制，可能会导致写消息的时候数据丢失，专业的消息中间件采用多集群的方式来规避这个问题

redis面对消息积压只能丢失一定的数据，而专业的消息中间件则将数据保存在磁盘上，比内存的空间要大很多。

redis的优点： 部署、运维轻量

## 总结

redis做消息队列还是适合与轻量的场景。

每个工具都有它的优劣，在技术选型的时候更要注意分析具体的场景：是否可以实现业务功能、是否可以hold住对应的工具···

任重道远··